use std::fmt::Display;

use iroh::NodeAddr;
use iroh_blobs::{ticket::BlobTicket, BlobFormat, Hash, HashAndFormat};
use serde::{Deserialize, Serialize};

use crate::crypto::PublicKey;

use super::ipld::{Cid, LinkedData, Multihash, BLAKE3_HASH_CODE, LD_CBOR_CODEC, LD_RAW_CODEC};

// TODO (pr-draft): this should be a CID
/// TODO (amiller68): revisit a better way to serialize this
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub struct Link(u64, Hash, BlobFormat);

impl Display for Link {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.1)
    }
}

// TODO (amiller68): i am really not sure if we need the BlobFormat
// ... idk if ever actually use it for retrieval
// We could just assume everything is raw unless under the specicific cicrumstances
//  that we know a blob is going to be HashSeq?
// Anyways, its liket this now, so we roll with it
/**
 * Links
 * =====
 * A Link is a reference to a block of data stored
 *  by the iroh-blobs protocol.
 * Links are implemented as Blake3 only multihashes
 *  which are interprettable as both CIDs and iroh_blobs::HashAndFormat
 * CIDs encoding is used to communicate the expected encoding of
 *  the referenced content, while HashAndFormat is used for the
 *  retrieval of data over the iroh_blobs protocol.
 * For our purposes, we keep the following assumptions:
 *  - hashes are always blake3, and usually generated by iroh-blobs
 *  - blob formats may be Raw or HashSeq. Most of our links will be Raw,
 *     we only use HashSeq for declaring a Bucket's pinset
 *  - links may either be RAW or DAG-CBOR encoded depending on whether they
 *   point to:
 *    - public raw data (RAW)
 *    - private raw data (RAW)
 *    - private structured data (RAW, but underlying format is DAG-CBOR)
 *    - public structured data (DAG-CBOR)
 */
#[allow(clippy::doc_overindented_list_items)]
#[allow(clippy::doc_lazy_continuation)]
impl Default for Link {
    fn default() -> Self {
        Link(LD_RAW_CODEC, Hash::from_bytes([0; 32]), BlobFormat::Raw)
    }
}

impl From<Link> for Cid {
    fn from(val: Link) -> Self {
        let hash = val.1;
        let mh = Multihash::wrap(BLAKE3_HASH_CODE, hash.as_bytes()).expect("valid blake3 hash");

        Cid::new_v1(
            val.0, // codec
            mh,
        )
    }
}

impl From<Cid> for Link {
    fn from(val: Cid) -> Self {
        let hash = val.hash();
        let code = hash.code();
        let codec = val.codec();
        // panic if we don't have a blake3 hash, this means
        //  it was not generated by our protocol
        if code != BLAKE3_HASH_CODE {
            panic!("invalid hash code");
        }
        // check we have one of our supported codecs
        if codec != LD_RAW_CODEC && codec != LD_CBOR_CODEC {
            panic!("unsupported codec");
        }

        // convert the hash to our internal representation
        //  by copying them into a fixed-size array
        let mut hash_bytes: [u8; 32] = [0; 32];
        hash_bytes.copy_from_slice(hash.digest());
        let hash = Hash::from_bytes(hash_bytes);
        Link(codec, hash, BlobFormat::Raw)
    }
}

impl From<Link> for LinkedData {
    fn from(val: Link) -> Self {
        let cid: Cid = val.clone().into();
        LinkedData::Link(cid)
    }
}

impl From<Link> for HashAndFormat {
    fn from(val: Link) -> Self {
        HashAndFormat {
            hash: val.1,
            format: val.2,
        }
    }
}

impl From<Link> for Hash {
    fn from(val: Link) -> Self {
        val.1
    }
}

impl Link {
    pub fn new(codec: u64, hash: Hash, format: BlobFormat) -> Self {
        Link(codec, hash, format)
    }

    pub fn codec(&self) -> &u64 {
        &self.0
    }

    pub fn hash(&self) -> &Hash {
        &self.1
    }

    pub fn format(&self) -> &BlobFormat {
        &self.2
    }

    pub fn ticket(&self, source: PublicKey) -> BlobTicket {
        // deref to get the inner public key
        let node_addr = NodeAddr::new(*source);
        // NOTE (amiller68): the initializer of blob ticket is essentially
        //  a no-op on version 0.35.0, so this is def safe
        BlobTicket::new(node_addr, self.1, self.2)
    }
}
